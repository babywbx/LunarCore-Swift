// Generates LunarYearData.swift from LunarCalendarComputer output.
// Usage: swift run GenerateData > Sources/LunarCore/Data/LunarYearData.swift

import Foundation
import LunarCore
#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#endif

let startYear = 1900
let endYear = 2100

func writeStderr(_ message: String) {
    FileHandle.standardError.write(Data((message + "\n").utf8))
}

// Encode a single lunar year into UInt32 per SPEC 4.3 bit layout:
// [31]    : reserved (0)
// [30-19] : 12 bits — month sizes (1=30d, 0=29d), bit30=M1..bit19=M12
// [18-15] : 4 bits  — leap month (0=none, 1-12)
// [14]    : 1 bit   — leap month size (1=30d, 0=29d)
// [13-9]  : 5 bits  — CNY day (1-31)
// [8]     : 1 bit   — CNY month (0=Jan, 1=Feb)
// [7-0]   : 8 bits  — reserved (0)
func encode(_ raw: LunarYearRaw) -> UInt32 {
    var bits: UInt32 = 0

    // Month sizes: 12 regular months (non-leap)
    let regularMonths = raw.months.filter { !$0.isLeapMonth }
    for (i, m) in regularMonths.enumerated() where i < 12 {
        if m.dayCount == 30 {
            bits |= 1 << UInt32(30 - i)
        }
    }

    // Leap month info
    if let leapMonth = raw.leapMonth {
        bits |= UInt32(leapMonth) << 15
        if let leapMonthRaw = raw.months.first(where: { $0.isLeapMonth }) {
            if leapMonthRaw.dayCount == 30 {
                bits |= 1 << 14
            }
        }
    }

    // CNY date
    let cny = raw.chineseNewYear
    bits |= UInt32(cny.day) << 9
    if cny.month == 2 {
        bits |= 1 << 8
    }

    return bits
}

// Generate data
var encoded: [UInt32] = []
var failures: [Int] = []

for year in startYear...endYear {
    guard let raw = LunarCalendarComputer.computeLunarYear(year: year) else {
        writeStderr("ERROR: failed to compute year \(year)")
        failures.append(year)
        encoded.append(0)
        continue
    }
    encoded.append(encode(raw))
}

if !failures.isEmpty {
    writeStderr("FATAL: \(failures.count) year(s) failed: \(failures)")
    exit(1)
}

// Print 2020-2030 summary to stderr for human review
writeStderr("")
writeStderr("=== 2020-2030 Lunar Year Summary ===")
for year in 2020...2030 {
    guard let raw = LunarCalendarComputer.computeLunarYear(year: year) else {
        writeStderr("\(year): FAILED")
        continue
    }
    let cny = raw.chineseNewYear
    let leap = raw.leapMonth.map { "leap \($0)" } ?? "no leap"
    let monthSizes = raw.months.map { m -> String in
        let prefix = m.isLeapMonth ? "L" : "M"
        return "\(prefix)\(m.month):\(m.dayCount)"
    }.joined(separator: " ")
    let packed = encode(raw)
    writeStderr(String(format: "%d: CNY=%d-%02d-%02d, %@, 0x%08X",
                       year, cny.year, cny.month, cny.day, leap, packed))
    writeStderr("  \(monthSizes)")
}
writeStderr("====================================")

// Write Swift source to stdout
print("// Auto-generated by GenerateData. DO NOT EDIT.")
print("// Lunar year data for \(startYear)-\(endYear) (\(encoded.count) years).")
print("// Each UInt32 encodes month sizes, leap month, and CNY date.")
print("// See SPEC.md 4.3 for bit layout.")
print("")
print("enum LunarYearData: Sendable, Equatable, Hashable {")
print("")
print("    static let startYear = \(startYear)")
print("    static let endYear = \(endYear)")
print("")
print("    // \(encoded.count) entries, index 0 = year \(startYear)")
print("    static let table: [UInt32] = [")

for (i, value) in encoded.enumerated() {
    let year = startYear + i
    let hex = String(format: "0x%08X", value)
    let comma = i < encoded.count - 1 ? "," : ""
    print("        \(hex)\(comma) // \(year)")
}

print("    ]")
print("}")
print("")
