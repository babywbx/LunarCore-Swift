import Foundation

/// A Gregorian (solar) calendar date.
///
/// Validated on creation; invalid dates (e.g. Feb 30) return `nil`.
public struct SolarDate: Equatable, Hashable, Comparable, Sendable {
    /// Gregorian year.
    public let year: Int
    /// Gregorian month (1–12).
    public let month: Int
    /// Gregorian day (1–31).
    public let day: Int

    /// Creates a solar date, returning `nil` if the date is invalid.
    public init?(year: Int, month: Int, day: Int) {
        guard SolarDate.isValid(year: year, month: month, day: day) else {
            return nil
        }
        self.year = year
        self.month = month
        self.day = day
    }

    // Internal fast path for already-validated dates generated by core algorithms.
    package init(uncheckedYear year: Int, month: Int, day: Int) {
        self.year = year
        self.month = month
        self.day = day
    }

    public static func < (lhs: SolarDate, rhs: SolarDate) -> Bool {
        if lhs.year != rhs.year { return lhs.year < rhs.year }
        if lhs.month != rhs.month { return lhs.month < rhs.month }
        return lhs.day < rhs.day
    }

    // MARK: - Foundation.Date interop

    /// Converts to `Foundation.Date` in the given time zone.
    public func toDate(in timeZone: TimeZone) -> Date? {
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = timeZone
        return cal.date(from: DateComponents(year: year, month: month, day: day))
    }

    /// Creates a `SolarDate` from a `Foundation.Date` in the given time zone.
    public static func from(_ date: Date, in timeZone: TimeZone) -> SolarDate? {
        var cal = Calendar(identifier: .gregorian)
        cal.timeZone = timeZone
        let c = cal.dateComponents([.year, .month, .day], from: date)
        guard let year = c.year, let month = c.month, let day = c.day else {
            return nil
        }
        return SolarDate(uncheckedYear: year, month: month, day: day)
    }

    /// Returns whether the given year/month/day forms a valid Gregorian date.
    public static func isValid(year: Int, month: Int, day: Int) -> Bool {
        guard (1...12).contains(month), day >= 1 else {
            return false
        }
        return day <= daysInMonth(year: year, month: month)
    }

    private static func daysInMonth(year: Int, month: Int) -> Int {
        switch month {
        case 1, 3, 5, 7, 8, 10, 12:
            return 31
        case 4, 6, 9, 11:
            return 30
        case 2:
            return isLeapYear(year) ? 29 : 28
        default:
            return 0
        }
    }

    private static func isLeapYear(_ year: Int) -> Bool {
        (year % 4 == 0 && year % 100 != 0) || year % 400 == 0
    }
}
